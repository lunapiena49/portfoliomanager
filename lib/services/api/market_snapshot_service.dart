import 'package:dio/dio.dart';

import '../../core/constants/app_constants.dart';

/// Fetches distributed market snapshot files generated by the serverless pipeline.
class MarketSnapshotService {
  final Dio _dio;

  static const Set<String> _exchangeSuffixes = <String>{
    'US',
    'USA',
    'NASDAQ',
    'NYSE',
    'AMEX',
    'BATS',
    'OTC',
    'OTCBB',
    'LSE',
    'LON',
    'XETRA',
    'FRA',
    'FSE',
    'PA',
    'EPA',
    'EURONEXT',
    'TO',
    'TSX',
    'TSXV',
    'HK',
    'HKG',
    'AU',
    'AX',
    'ASX',
    'NSE',
    'BSE',
  };

  /// In-memory cache for prices_index to avoid repeated downloads in a session.
  Map<String, dynamic>? _cachedPricesIndex;
  DateTime? _pricesIndexCachedAt;
  static const Duration _pricesIndexCacheTtl = Duration(hours: 4);

  MarketSnapshotService({Dio? dio}) : _dio = dio ?? Dio() {
    _dio.options.connectTimeout = AppConstants.apiTimeout;
    _dio.options.receiveTimeout = AppConstants.apiTimeout;
  }

  bool get isConfigured => AppConstants.marketSnapshotBaseUrl.trim().isNotEmpty;

  String get _baseUrl {
    final url = AppConstants.marketSnapshotBaseUrl.trim();
    return url.endsWith('/') ? url.substring(0, url.length - 1) : url;
  }

  Future<Map<String, dynamic>?> fetchTopMoversSnapshot() async {
    if (!isConfigured) return null;
    final response = await _dio.get('$_baseUrl/top_movers.json');
    final payload = response.data;
    if (payload is! Map) return null;
    return Map<String, dynamic>.from(payload);
  }

  /// Downloads and caches the prices_index.json snapshot.
  ///
  /// Returns a map keyed by ``MARKET:TICKER`` and ``TICKER`` (flat) with
  /// compact price entries: {c: close, cu: currency, m: market, d: date}.
  Future<Map<String, dynamic>?> fetchPricesIndex(
      {bool forceRefresh = false}) async {
    if (!isConfigured) return null;

    final now = DateTime.now();
    if (!forceRefresh &&
        _cachedPricesIndex != null &&
        _pricesIndexCachedAt != null &&
        now.difference(_pricesIndexCachedAt!) < _pricesIndexCacheTtl) {
      return _cachedPricesIndex;
    }

    try {
      final response = await _dio.get('$_baseUrl/prices_index.json');
      final payload = response.data;
      if (payload is! Map) return null;

      final prices = payload['prices'];
      if (prices is! Map) return null;

      _cachedPricesIndex = Map<String, dynamic>.from(prices);
      _pricesIndexCachedAt = now;
      return _cachedPricesIndex;
    } catch (_) {
      return null;
    }
  }

  /// Looks up a snapshot price for [ticker] (optionally with [marketCode]).
  ///
  /// Lookup order: ``{MARKET}:{TICKER}`` â†’ flat ``{TICKER}``.
  /// Returns ``{c, cu, m, d}`` or null if not found.
  ///
  /// It also normalizes common broker symbol formats (e.g. ``AAPL.US``,
  /// ``BRK.B``) to reduce false "price not found" cases.
  Map<String, dynamic>? lookupPrice(
    Map<String, dynamic> pricesIndex, {
    required String ticker,
    String? marketCode,
  }) {
    final candidates = _buildTickerCandidates(ticker);
    if (candidates.isEmpty) {
      return null;
    }

    final normalizedMarket = marketCode?.trim().toUpperCase();
    if (normalizedMarket != null && normalizedMarket.isNotEmpty) {
      for (final candidate in candidates) {
        final mk = '$normalizedMarket:$candidate';
        final entry = pricesIndex[mk];
        if (entry is Map) return Map<String, dynamic>.from(entry);
      }
    }

    for (final candidate in candidates) {
      final flat = pricesIndex[candidate];
      if (flat is Map) return Map<String, dynamic>.from(flat);
    }

    return null;
  }

  /// Normalizes a symbol used by broker imports/API inputs into snapshot format.
  String normalizeTicker(String ticker) {
    final candidates = _buildTickerCandidates(ticker);
    return candidates.isEmpty ? '' : candidates.first;
  }

  List<String> _buildTickerCandidates(String ticker) {
    final raw = ticker.trim().toUpperCase().replaceAll(' ', '');
    if (raw.isEmpty) {
      return const <String>[];
    }

    final candidates = <String>{raw};

    final stripped = _stripExchangeSuffix(raw);
    if (stripped != null && stripped.isNotEmpty) {
      candidates.add(stripped);
    }

    final toInspect = <String>{...candidates};
    for (final value in toInspect) {
      final classMatch =
          RegExp(r'^([A-Z0-9]+)[./-]([A-Z0-9]{1,2})$').firstMatch(value);
      if (classMatch != null) {
        final base = classMatch.group(1)!;
        final shareClass = classMatch.group(2)!;
        candidates.add('$base-$shareClass');
        candidates.add('$base.$shareClass');
        candidates.add('$base/$shareClass');
      }

      if (value.contains('.')) {
        candidates.add(value.replaceAll('.', '-'));
      }
      if (value.contains('/')) {
        candidates.add(value.replaceAll('/', '-'));
      }
    }

    return candidates.toList(growable: false);
  }

  String? _stripExchangeSuffix(String ticker) {
    for (final separator in const ['.', ':', '/', '-']) {
      final idx = ticker.lastIndexOf(separator);
      if (idx <= 0 || idx >= ticker.length - 1) {
        continue;
      }
      final suffix = ticker.substring(idx + 1);
      if (_exchangeSuffixes.contains(suffix)) {
        return ticker.substring(0, idx);
      }
    }
    return null;
  }

  void clearPricesIndexCache() {
    _cachedPricesIndex = null;
    _pricesIndexCachedAt = null;
  }
}
