import 'package:dio/dio.dart';

import '../../core/constants/app_constants.dart';

/// Fetches distributed market snapshot files generated by the serverless pipeline.
class MarketSnapshotService {
  final Dio _dio;

  /// In-memory cache for prices_index to avoid repeated downloads in a session.
  Map<String, dynamic>? _cachedPricesIndex;
  DateTime? _pricesIndexCachedAt;
  static const Duration _pricesIndexCacheTtl = Duration(hours: 4);

  MarketSnapshotService({Dio? dio}) : _dio = dio ?? Dio() {
    _dio.options.connectTimeout = AppConstants.apiTimeout;
    _dio.options.receiveTimeout = AppConstants.apiTimeout;
  }

  bool get isConfigured => AppConstants.marketSnapshotBaseUrl.trim().isNotEmpty;

  String get _baseUrl {
    final url = AppConstants.marketSnapshotBaseUrl.trim();
    return url.endsWith('/') ? url.substring(0, url.length - 1) : url;
  }

  Future<Map<String, dynamic>?> fetchTopMoversSnapshot() async {
    if (!isConfigured) return null;
    final response = await _dio.get('$_baseUrl/top_movers.json');
    final payload = response.data;
    if (payload is! Map) return null;
    return Map<String, dynamic>.from(payload);
  }

  /// Downloads and caches the prices_index.json snapshot.
  ///
  /// Returns a map keyed by ``MARKET:TICKER`` and ``TICKER`` (flat) with
  /// compact price entries: {c: close, cu: currency, m: market, d: date}.
  Future<Map<String, dynamic>?> fetchPricesIndex({bool forceRefresh = false}) async {
    if (!isConfigured) return null;

    final now = DateTime.now();
    if (!forceRefresh &&
        _cachedPricesIndex != null &&
        _pricesIndexCachedAt != null &&
        now.difference(_pricesIndexCachedAt!) < _pricesIndexCacheTtl) {
      return _cachedPricesIndex;
    }

    try {
      final response = await _dio.get('$_baseUrl/prices_index.json');
      final payload = response.data;
      if (payload is! Map) return null;

      final prices = payload['prices'];
      if (prices is! Map) return null;

      _cachedPricesIndex = Map<String, dynamic>.from(prices);
      _pricesIndexCachedAt = now;
      return _cachedPricesIndex;
    } catch (_) {
      return null;
    }
  }

  /// Looks up a snapshot price for [ticker] (optionally with [marketCode]).
  ///
  /// Lookup order: ``{MARKET}:{TICKER}`` â†’ flat ``{TICKER}``.
  /// Returns ``{c, cu, m, d}`` or null if not found.
  Map<String, dynamic>? lookupPrice(
    Map<String, dynamic> pricesIndex, {
    required String ticker,
    String? marketCode,
  }) {
    final t = ticker.trim().toUpperCase();
    if (marketCode != null && marketCode.trim().isNotEmpty) {
      final mk = '${marketCode.trim().toUpperCase()}:$t';
      final entry = pricesIndex[mk];
      if (entry is Map) return Map<String, dynamic>.from(entry);
    }
    final flat = pricesIndex[t];
    if (flat is Map) return Map<String, dynamic>.from(flat);
    return null;
  }

  void clearPricesIndexCache() {
    _cachedPricesIndex = null;
    _pricesIndexCachedAt = null;
  }
}
